% Super irritating style check
:- style_check(-atom).

% Meta error handling
:- ensure_loaded('../io/meta_error').

% The grammar for symbolic equations
:- use_module(symbolic_equation).

% The grammar for word equations
:- use_module(word_equation).

% Rules for handling compounds
:- consult('../formula/compounder').

% Rebase procedure (creates lookup tables, merges re-occurences of elements in a formula, flattens polyatomic groups)
:- use_module(tabulate).

% The solver (converts the coefficient set to a system of linear equations and solves it).
:- use_module(solve).



balance_equation_real(InGrammar,Equation,OutGrammar,Solution) :-
	parse(InGrammar,.(user,_,[],Elems,[],MoleculeSet,[],SideSet),Equation,[]),
	(
		tabulate(SideSet); 
		throw(error(type_error(user:equation_struct,SideSet),_))
	),
	sort(Elems,ElementSet),

	(
		matrix(MoleculeSet,ElementSet,Matrix); 
		throw(error(type_error(user:data_sets,
		(molecules(MoleculeSet),elements(ElementSet))
		),_))
	),
	!,

	solve(Matrix,Coeffs),
	!,

	parse(OutGrammar,.(output,Coeffs,[],Elems,[],MoleculeSet,[],SideSet),Solution,[]).


/** balance_equation(+InGrammar,+Equation,+OutGrammar,?Solution) is semidet.
 ** balance_equation(+Equation,?Solution) is semidet.

These functions act as a wrapper around balance_equation_real. They retract the facts generated by tabulate regardless of whether or not the balancing suceeded.
The second function sets some default parameters.

@arg	InGrammar	The type of equation that is being input.	(symbolic or word).
@arg	Equation	The equation as a quoted string	"CH4 + O2 ..."
@arg	OutGrammar	The type of equation that will be output.	(symbolic or word)
@arg	Solution	An equation, with coefficients solved.	"CH4 + *2*O2 ..."
*/
balance_equation_cleanup(InGrammar,Equation,OutGrammar,Solution) :-
	balance_equation_real(InGrammar,Equation,OutGrammar,Solution) -> retractall(balance(_,_,_));
	(retractall(balance(_,_,_)), fail).

balance_equation(InGrammar,Equation,OutGrammar,Solution) :-
	catch(
	catch(
		balance_equation_cleanup(InGrammar,Equation,OutGrammar,Solution),
		error(type_error(Type,Data),_),
		explain_rethrow_process(Equation,Type,Data)
	),
	error(domain_error(Type,Data),_),
	explain_rethrow_domain(Equation,Type,Data)).


balance_equation(Equation,Solution) :- balance_equation(symbolic,Equation,symbolic,Solution).


matrix(_,[],[]) :- !.

matrix(MolSet,[Elem|ElemS],[Row|RowS]) :-
	element_count(MolSet,Elem,Row),
	matrix(MolSet,ElemS,RowS).


element_count([],_,[]).

element_count([Mol|MolS],Elem,[Count|CountS]) :-
      (balance(Mol,Elem,Count) ; Count = 0),
        element_count(MolS,Elem,CountS),
        !.



%%%%% GUIDANCE FOR ERRORS %%%%%

guidance_process(equation_struct,
	'Your equation has been completely parsed but the structure that 
	 has been constructed from it is not correct and cannot be used 
	 to balance the equation.
	
	 INTERNAL LOGIC ERROR --- this is probably a bug in the program.

 	 Equation in internal format: ').

guidance_process(data_sets,
	'Your equation has been completely parsed, but the information
	collected about the contained molecules and elements is not
	correct and cannot be used to construct a matrix.

	INTERNAL LOGIC ERROR --- this is probably a bug in the program.

	The collected data sets: ').

explain_data([],[]).
% vi: ft=prolog
