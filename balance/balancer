% balancer: The main file for the balancing library. Implements the balancing predicates.
% This file is from Chemlogic, a logic programming computer chemistry system
% <http://icebergsystems.ca/chemlogic>
% (C) Copyright 2012-2015 Nicholas Paun



% Super irritating style check
:- style_check(-atom).

% Meta error handling
:- ensure_loaded('../io/meta_error').

% The grammar for symbolic equations
:- use_module(symbolic_equation).

% The grammar for word equations
:- use_module(word_equation).

% Rules for handling compounds
:- consult('../formula/compounder').

% Rebase procedure (creates lookup tables, merges re-occurences of elements in a formula, flattens polyatomic groups)
:- use_module(tabulate).

% The solver (converts the coefficient set to a system of linear equations and solves it).
:- use_module(solve).



balance_equation_real(InGrammar,Equation,OutGrammar,Solution,Coeffs,MoleculeSet) :-
	parse(InGrammar,.(user,_,[],Elems,[],MoleculeSet,[],ElementSideSet,SideSet),Equation,[]),
	(
		tabulate(SideSet); 
		throw(error(type_error(user:equation_struct,SideSet),_))
	),
	sort(Elems,ElementSet),
	test_elements(ElementSet,ElementSideSet),
	(
		matrix(MoleculeSet,ElementSet,Matrix); 
		throw(error(type_error(user:data_sets,
		(molecules(MoleculeSet),elements(ElementSet))
		),_))
	),
	!,

	solve(Matrix,Coeffs),
	!,

	parse(OutGrammar,.(output,Coeffs,[],Elems,[],MoleculeSet,[],ElementSideSet,SideSet),Solution,[]).


balance_equation_cleanup :-
	retractall(balance(_,_,_)).


/** balance_equation(+InGrammar:grammar,+Equation:string,+OutGrammar:grammar,?Solution:string,?Coeffs:list,?Formulas:list) is semidet.
 ** balance_equation(+InGrammar:grammar,+Equation:string,+OutGrammar:grammar,?Solution:string) is semidet.
 ** balance_equation(+Equation:string,?Solution:string) is semidet.

These functions act as a wrapper around balance_equation_real. They retract the facts generated by tabulate regardless of whether or not the balancing suceeded.
The second function sets some default parameters.

@arg	InGrammar	The type of equation that is being input.		(symbolic or word).
@arg	Equation	The equation as a quoted string. 			e.g.	"CH4 + O2 ..."
@arg	OutGrammar	The type of equation that will be output.		(symbolic or word)
@arg	Solution	An equation, with coefficients solved.			e.g. "CH4 + *2*O2 ..."
@arg	Coeffs		A list of the coefficients of the balanced equation. 	e.g. [1,2,1,2]
@arg	Formulas	A list of the formulas of the equation, as structs.	e.g. [[[["C",1],["H",4]]...
*/


balance_equation(InGrammar,Equation,OutGrammar,Solution,Coeffs,MoleculeSet) :-
	catch(
	catch(
		call_cleanup(balance_equation_real(InGrammar,Equation,OutGrammar,Solution,Coeffs,MoleculeSet),balance_equation_cleanup),
		error(type_error(Type,Data),_),
		explain_general_rethrow(type_error,Equation,Type,Data)
	),
	error(domain_error(Type,Data),_),
	explain_general_rethrow(domain_error,Equation,Type,Data)).


balance_equation(InGrammar,Equation,OutGrammar,Solution) :- balance_equation(InGrammar,Equation,OutGrammar,Solution,_,_).
balance_equation(Equation,Solution) :- balance_equation(symbolic,Equation,symbolic,Solution,_,_).

/** matrix(+MolSet:list,+ElemSet:list,?Rows:list) is semidet.

	Produces a matrix representing the chemical equation, with rows representing chemical elements and columns representing molecules.
	This is done by iterating through structures produced by the chemical equation DCG and reading corresponding tabulated values representing total occurences of elements.

@arg	MolSet		A set of the formulas of all of the chemicals in an equation.	
@arg	ElemSet		A set of all of the elements involved in an equation.
@arg	Rows		The corresponding matrix.
**/

matrix(_,[],[]) :- !.

matrix(MolSet,[Elem|ElemS],[Row|RowS]) :-
	element_count(MolSet,Elem,Row),
	matrix(MolSet,ElemS,RowS).


element_count([],_,[]).

element_count([Mol|MolS],Elem,[Count|CountS]) :-
      (balance(Mol,Elem,Count) ; Count = 0),
      element_count(MolS,Elem,CountS),
      !.

/** test_elements(+Elements:list,+ElementSideSet:list) is semidet.

	Ensures that all chemical equations conform to the Law of Conservation of Atoms, which states that all the atoms involved in a reaction must be present in both the reactants and the products. This predicate verifies this by identifying any elements present in the overall reaction that are not present in one part of the reaction.

	The exception and error message it raises helps explain a common mistake.

@arg	Elements	A list of all of the elements in the chemical equation					e.g. ["C","H","O"]
@arg	ElementSideSet	A list of all the elements in a chemical equation, separated by side of reaction.	e.g. [["C","H"],["O"]]
**/

test_elements(Elements,[Reactants,Products]) :-
	subtract(Elements,Reactants,MissingReactants),
	subtract(Elements,Products,MissingProducts),
	(
		(
			MissingReactants = [],
			MissingProducts = []
		); 

		throw(error(domain_error(user:missing_elements,
			(
				'Elements missing from reactants:', MissingReactants,
				'		Elements missing from products:', MissingProducts
			)
		), _)
		)
	).


%%%%% GUIDANCE FOR ERRORS %%%%%

guidance_general(equation_struct,
	'Your equation completely follows the rules for chemical equations, but the information from the equation could not be used to make a lookup table.
	 The two formats may be incompatible for some reason.	 
	
	 INTERNAL LOGIC ERROR --- this is probably a bug in the program.

 	 Equation in internal format: ').

guidance_general(data_sets,
	'Your equation completely follows the rules for chemical equations, but the information collected while processing the equation could not be used to construct a matrix.
	
 	 INTERNAL LOGIC ERROR --- this is probably a bug in the program.

	The collected data sets: ').

guidance_general(missing_elements,
	'You are missing elements (or entire substances) from either the reactants or the products. Therefore, the equation is unbalancable.
	 Since atoms cannot be created or destroyed in a chemical reaction, all of the elements present in the reactants must be present in the products.
	
 	Please check to ensure you have entered the entire equation and all of its names/formulas correctly.
 	
 	').

explain_general_data([],[]).
% vi: ft=prolog
